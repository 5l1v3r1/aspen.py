"""A few default handlers for aspen.
"""
import mimetypes
import rfc822
import os
import stat
import traceback
from email import message_from_file, message_from_string
from os.path import isdir, isfile, join

from aspen import mode, __version__
from aspen.utils import is_valid_identifier


# File or Directory
# =================

def HTTP404(environ, start_response):
    start_response('404 Not Found', [])
    return ['Resource not found.']


# File Handlers
# =============

def pyscript(environ, start_response):
    """Execute the script pseudo-CGI-style.
    """
    path = environ['PATH_TRANSLATED']
    assert isfile(path)

    context = dict()
    context['environ'] = environ
    context['start_response'] = start_response
    context['response'] = []
    context['__file__'] = path

    try:
        exec open(path) in context
        response = context['response']
    except SystemExit:
        pass
#    except:
#        start_response( '500 Internal Server Error'
#                      , [('Content-type', 'text/plain')]
#                       )
#        if mode.debdev:
#            return [traceback.format_exc()]
#        else:
#            return ['Internal Server Error']

    return response


def static(environ, start_response):
    """Serve a static file off of the filesystem.

    In staging and deployment modes, we honor any 'If-Modified-Since'
    header, an HTTP header used for caching.

    XXX: look at Luke Arno's ACK GPL and some others ... Etags? Iteration?

    """
    assert isfile(environ['PATH_TRANSLATED'])

    path = environ['PATH_TRANSLATED']
    ims = environ.get('HTTP_IF_MODIFIED_SINCE', '')


    # Get basic info from the filesystem and start building a response.
    # =================================================================

    stats = os.stat(path)
    mtime = stats[stat.ST_MTIME]
    size = stats[stat.ST_SIZE]
    content_type = mimetypes.guess_type(path)[0] or 'text/plain'


    # Support 304s, but only in deployment mode.
    # ==========================================

    status = '200 OK'
    if mode.stprod:
        if ims:
            mod_since = rfc822.parsedate(ims)
            last_modified = time.gmtime(mtime)
            if last_modified[:6] <= mod_since[:6]:
                status = '304 Not Modified'


    # Set up the response.
    # ====================

    headers = []
    headers.append(('Last-Modified', rfc822.formatdate(mtime)))
    headers.append(('Content-Type', content_type))
    headers.append(('Content-Length', str(size)))

    start_response(status, headers)
    if status == '304 Not Modified':
        return []
    else:
        return open(path)


# Directory Handlers
# ==================

def autoindex(environ, start_response):
    """Serve an automatic index for a directory.
    """
    assert isdir(environ['PATH_TRANSLATED'])

    _path = '/'.join(path.split(os.sep))
    urlpath = _path[len(environ['aspen.website'].paths.root):]

    out = ['<html><head><title>%s</title></head><body>' % urlpath]
    out.append('<h1>%s</h1>' % urlpath)
    out.append('<ul>')
    for name in os.listdir(path):
        _path = '/'.join(urlpath, name)
        out.append('<li><a href="">%s</a></li>' % (_path, name))
    out.append('</ul>')
    out.append('<hr /><i>Generated by <a href="http://www.zetadev.com/software/aspen/">Aspen %s</a>' % __version__)
    out.append('</body></html>')
    return out


def default(environ, start_response):
    """Try to serve a default resource.
    """
    path = environ['PATH_TRANSLATED']
    assert isdir(path)
    defaults = environ['aspen.website'].config.defaults
    assert defaults is not None

    default = None
    for name in defaults:
        _path = join(path, name)
        if isfile(_path):
            default = _path
            break
    if default is None:
        if 'aspen.autoindex_next' in environ:
            return None
        start_response('403 Forbidden', [])
        return ['No default resource for this directory.']
    path = environ['PATH_TRANSLATED'] = default

    new_handler = environ['aspen.website'].get_handler(path)
    return new_handler.handle(environ, start_response)


def default_or_autoindex(environ, start_response):
    """Serve a default file; failing that, an autoindex.
    """
    assert isdir(environ['PATH_TRANSLATED'])
    environ['aspen.autoindex_next'] = True
    response = default(environ, start_response)
    if response is None:
        response = autoindex(environ, start_response)
    return response
